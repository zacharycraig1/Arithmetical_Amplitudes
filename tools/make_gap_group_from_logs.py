"""
Create a GAP script that defines the permutation group generated by the
tau/sigma permutations we have observed in publication_ready/logs/D24_*.log.

This is meant to help identify the *actual* group we are generating (e.g. size
2304 group) and compare it to TransitiveGroup(24,34) (24T34).

Run (from repo root):
  python publication_ready/tools/make_gap_group_from_logs.py

Then run GAP inside Sage Docker (from publication_ready/):
  docker run --rm -v "${PWD}:/home/sage/work" -w /home/sage/work sagemath/sagemath:10.4 gap -q tools/generated_group_from_logs.g
"""

from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import List, Optional, Tuple

import analyze_perm_group as apg


def perm_to_gap_cycles(perm: List[int]) -> str:
    """Convert 1-indexed perm array into GAP cycle notation string."""
    cycs = apg.cycle_decomposition(perm)
    if not cycs:
        return "()"
    parts = []
    for cyc in cycs:
        parts.append("(" + ",".join(str(i) for i in cyc) + ")")
    return "".join(parts)


@dataclass(frozen=True)
class Extracted:
    tau: List[int]
    sigmas: List[List[int]]  # unique non-identity sigmas


def extract_from_logs(logs_dir: Path, n: int = 24) -> Extracted:
    tau: Optional[List[int]] = None
    sigmas: List[List[int]] = []
    for p in sorted(logs_dir.glob("D24_*.log")):
        ts = apg.extract_tau_sigma(p)
        if not ts:
            continue
        tau_s, sigma_s = ts
        if tau is None:
            tau = apg.parse_gap_cycles(tau_s, n)
        sigma = apg.parse_gap_cycles(sigma_s, n)
        if sigma == list(range(n + 1)):
            continue
        sigmas.append(sigma)
    if tau is None:
        raise RuntimeError(f"No tau found in logs under {logs_dir}")
    # dedupe sigmas
    uniq: List[List[int]] = []
    seen = set()
    for s in sigmas:
        t = tuple(s)
        if t in seen:
            continue
        seen.add(t)
        uniq.append(s)
    return Extracted(tau=tau, sigmas=uniq)


def main() -> None:
    repo_root = Path(__file__).resolve().parents[2]
    logs_dir = repo_root / "publication_ready" / "logs"
    out_path = repo_root / "publication_ready" / "tools" / "generated_group_from_logs.g"

    ext = extract_from_logs(logs_dir)
    tau_gap = perm_to_gap_cycles(ext.tau)
    sigma_gaps = [perm_to_gap_cycles(s) for s in ext.sigmas]

    lines: List[str] = []
    lines.append("# Autogenerated by make_gap_group_from_logs.py")
    lines.append("# Group generated by tau and observed sigmas from logs.")
    lines.append("")
    lines.append(f"tau := {tau_gap};")
    for i, s in enumerate(sigma_gaps, start=1):
        lines.append(f"sigma{i} := {s};")
    sig_list = ",".join([f"sigma{i}" for i in range(1, len(sigma_gaps) + 1)])
    if sig_list:
        lines.append(f"G := Group(tau, {sig_list});")
    else:
        lines.append("G := Group(tau);")
    lines.append("")
    lines.append('Print("Generators: tau + %d sigma(s)\\n");' % len(sigma_gaps))
    lines.append('Print("Order(G) = ", Size(G), "\\n");')
    lines.append('Print("StructureDescription(G) = ", StructureDescription(G), "\\n");')
    lines.append('Print("IsTransitive(G,[1..24]) = ", IsTransitive(G,[1..24]), "\\n");')
    lines.append('Print("IsPrimitive(G,[1..24]) = ", IsPrimitive(G,[1..24]), "\\n");')
    lines.append("")
    lines.append("# Compare to LMFDB label 24T34 (TransitiveGroup(24,34))")
    lines.append("T := TransitiveGroup(24,34);")
    lines.append('Print("Order(24T34) = ", Size(T), "\\n");')
    lines.append('Print("StructureDescription(24T34) = ", StructureDescription(T), "\\n");')
    lines.append("# GAP core provides IsomorphismGroups; IsIsomorphic may not be loaded.")
    lines.append("iso := IsomorphismGroups(G, T);")
    lines.append('Print("IsomorphismGroups(G,24T34) found? ", iso <> fail, "\\n");')
    lines.append("")
    lines.append("# Orbits / block structure on [1..24]")
    lines.append("orbs := Orbits(G, [1..24]);")
    lines.append('Print("Orbits sizes: ", List(orbs, Size), "\\n");')
    lines.append('Print("Orbits: ", orbs, "\\n");')
    lines.append("")
    lines.append("# Sylow subgroups")
    lines.append("Syl2 := SylowSubgroup(G, 2);")
    lines.append("Syl3 := SylowSubgroup(G, 3);")
    lines.append('Print("Sylow-2 order = ", Size(Syl2), "  structure = ", StructureDescription(Syl2), "\\n");')
    lines.append('Print("Sylow-3 order = ", Size(Syl3), "  structure = ", StructureDescription(Syl3), "\\n");')
    lines.append("")
    lines.append("# Subgroups of order 48 (possible D48 = dihedral of order 48)")
    lines.append("cc := ConjugacyClassesSubgroups(G);")
    lines.append("cand := Filtered(cc, c -> Size(Representative(c)) = 48);")
    lines.append('Print("# conjugacy classes of subgroups of order 48: ", Length(cand), "\\n");')
    lines.append("for c in cand do")
    lines.append("  H := Representative(c);")
    lines.append('  Print("  H structure: ", StructureDescription(H), "  normal=", IsNormal(G,H), "\\n");')
    lines.append("od;")
    lines.append("")
    lines.append("# Try the subgroup generated by tau alone")
    lines.append("Ht := Group(tau);")
    lines.append('Print("Order(<tau>) = ", Size(Ht), " normal=", IsNormal(G, Ht), "\\n");')
    lines.append("")

    out_path.write_text("\n".join(lines) + "\n", encoding="utf-8")
    print(f"Wrote {out_path} with {len(sigma_gaps)} sigma generator(s).")


if __name__ == '__main__':
    main()

